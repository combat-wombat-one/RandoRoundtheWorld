<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>VR GeoGuessr - MapLibre Optimized</title>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- *** FIX: Replaced Leaflet with MapLibre GL JS *** -->
  <script src='https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js'></script>
  <link href='https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css' rel='stylesheet' />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap" rel="stylesheet">
<style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background: url('splash.png') no-repeat center center fixed;
    background-size: cover;
  }
  #startButton {
    font-family: 'Orbitron', sans-serif;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 40px;
    font-size: 30px;
    background: #e0202d;
    color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    z-index: 999;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  #mapContainer {
    position: fixed;
    top: -10000px;
    left: -10000px;
    width: 1024px;
    height: 640px;
  }
</style>
</head>
<body>

<button id="startButton">Click me with your Controller to Start Game!</button>
<div id="mapContainer"></div>

<a-scene id="scene" 
         webxr="referenceSpaceType: local-floor"
         vr-mode-ui="enabled: true"
         renderer="antialias: true; logarithmicDepthBuffer: true"
         visible="false">
         
  <a-assets id="assets-container">
    <img id="fallback" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z/C/HgAGgwJ/lK3Q6wAAAABJRU5ErkJggg==" crossorigin="anonymous">
    <!-- *** FIX: A single, reusable image element for the panorama *** -->
    <img id="pano-image" crossorigin="anonymous">
  </a-assets>
  
  <a-sky id="sky" material="shader: flat; color: #333"></a-sky>
  
  <a-entity id="cameraRig" position="0 1.6 0">
    <a-camera id="camera" wasd-controls-enabled="false">
      <a-entity id="vrLoadingText" visible="false" position="0 0 -1.5">
          <a-entity troika-text="value: Loading...; align: center; color: white; fontSize: 0.1;"></a-entity>
      </a-entity>
    </a-camera>
    <a-entity id="rightController" oculus-touch-controls="hand: right" laser-controls="hand: right" raycaster="objects: .clickable; far: 20;"></a-entity>
  </a-entity>
  
  <a-entity id="uiWrapper" visible="false">
      <a-entity id="gameUI" position="0 1.2 -2.5">
        <a-plane id="guessBtn" class="clickable" position="0 0 0" width="1.2" height="0.4" color="#9C27B0" visible="false">
            <a-entity troika-text="value: MAKE GUESS; align: center; color: white; fontSize: 0.1; font: Orbitron.ttf;" position="0 0 0.01"></a-entity>
        </a-plane>
        <a-plane id="confirmBtn" class="clickable" position="0 0 0" width="1.2" height="0.4" color="#FF9800" visible="false">
            <a-entity troika-text="value: CONFIRM GUESS; align: center; color: white; fontSize: 0.1; font: Orbitron.ttf;" position="0 0 0.01"></a-entity>
        </a-plane>
        <a-plane id="nextRoundBtn" class="clickable" position="0 0 0" width="1.2" height="0.4" color="#4CAF50" visible="false">
            <a-entity troika-text="value: NEXT ROUND; align: center; color: white; fontSize: 0.1; font: Orbitron.ttf;" position="0 0 0.01"></a-entity>
        </a-plane>
      </a-entity>
      
      <a-entity id="mapWrapper" position="-2.5 1.5 -2.5" rotation="0 35 0" visible="false">
        <a-plane id="mapPanel" class="clickable" width="2" height="1.25" material="shader: flat; side: double; transparent: true;">
          <a-entity id="locationText" position="0 -0.75 0.01" troika-text="value:; align: center; color: black; fontSize: 0.06; outlineWidth: 0.005; outlineColor: #FFF; font: Orbitron.ttf;" ></a-entity>
        </a-plane>
        <a-entity id="mapPin" visible="false">
            <a-cone color="red" radius-bottom="0.03" radius-top="0" height="0.1" position="0 0.05 0.01" rotation="-90 0 0"></a-cone>
        </a-entity>
      </a-entity>
      
      <a-entity id="scoreAndTimer" position="0 2.8 -2.5">
        <a-entity id="scoreText" position="0 0 0" troika-text="value: SCORE: 0; align: center; color: white; fontSize: 0.1; font: Orbitron.ttf;"></a-entity>
        <a-entity id="timerText" position="0.9 0 0" troika-text="value: 02:00; align: right; color: white; fontSize: 0.1; font: Orbitron.ttf;"></a-entity>
      </a-entity>
      
      <a-entity id="resultsPanel" position="0 1.9 -2.5" visible="false">
        <a-plane width="2.2" height="1.2" color="#333333" opacity="0.9">
          <a-entity id="resultsText" position="0 0 0.01" troika-text="value:; align: center; color: white; fontSize: 0.07; whiteSpace: normal; maxWidth: 2; font: Orbitron.ttf;"></a-entity>
        </a-plane>
      </a-entity>
  </a-entity>
</a-scene>

<script>
class VRGeoGuessr {
  constructor() {
    // DOM Elements
    this.mapContainer = document.getElementById('mapContainer');
    this.startButton = document.getElementById('startButton');
    this.scene = document.getElementById('scene');
    this.sky = document.getElementById('sky');
    this.panoImage = document.getElementById('pano-image');

    // UI Elements
    this.uiWrapper = document.getElementById('uiWrapper');
    this.vrLoadingText = document.getElementById('vrLoadingText');
    this.guessBtn = document.getElementById('guessBtn');
    this.confirmBtn = document.getElementById('confirmBtn');
    this.nextRoundBtn = document.getElementById('nextRoundBtn');
    this.mapWrapper = document.getElementById('mapWrapper');
    this.mapPanel = document.getElementById('mapPanel');
    this.mapPin = document.getElementById('mapPin');
    this.locationText = document.getElementById('locationText');
    this.scoreText = document.getElementById('scoreText');
    this.timerText = document.getElementById('timerText');
    this.resultsPanel = document.getElementById('resultsPanel');
    this.resultsText = document.getElementById('resultsText');

    // State
    this.data = [];
    this.gamePlaylist = [];
    this.map = null;
    this.guessMarker = null;
    this.score = 0;
    this.round = 0;
    this.totalRounds = 5;
    this.timer = null;
    this.timeLeft = 120;
    this.currentGuess = null;
    this.acceptingInput = false;

    this.bindEvents();
  }

  bindEvents() {
    this.startButton.addEventListener('click', () => this.initExperience());
    this.guessBtn.addEventListener('click', () => { if (this.acceptingInput) this.startGuessing(); });
    this.confirmBtn.addEventListener('click', () => { if (this.acceptingInput) this.submitGuess(); });
    this.nextRoundBtn.addEventListener('click', () => { if (this.acceptingInput) this.startNewRound(); });
    this.mapPanel.addEventListener('click', (event) => {
        if (this.acceptingInput && this.mapWrapper.getAttribute('visible') && event.detail.intersection) {
            this.handleControllerMapClick(event.detail.intersection.uv);
        }
    });
  }

  initExperience() {
    this.startButton.style.display = 'none';
    this.scene.setAttribute('visible', 'true');
    this.vrLoadingText.setAttribute('visible', 'true');
    this.scene.enterVR().then(() => this.loadAndStartGame())
      .catch(err => { console.error("Could not enter VR mode:", err); this.loadAndStartGame(); });
  }
  
  async loadAndStartGame() {
    console.log("VR Session started. Loading assets...");
    try {
        const controllerPromise = new Promise(resolve => this.scene.addEventListener('controllerconnected', resolve, { once: true }));
        this.initMap();
        await this.loadCSV();
        this.generateGamePlaylist();
        
        console.log("Waiting for controllers to connect...");
        await controllerPromise;
        console.log("Controllers connected.");
        
        this.uiWrapper.setAttribute('visible', 'true');
        this.startNewRound();
    } catch(error) {
        this.vrLoadingText.setAttribute('troika-text', 'value', `Error: ${error.message}`);
    }
  }

  updateTimer() {
    const minutes = Math.floor(this.timeLeft / 60);
    const seconds = this.timeLeft % 60;
    this.timerText.setAttribute('troika-text', 'value', `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);
  }

  startTimer() {
    this.updateTimer();
    this.timer = setInterval(() => {
      this.timeLeft--; this.updateTimer();
      if (this.timeLeft <= 0) { clearInterval(this.timer); this.endRound(false); }
    }, 1000);
  }

  resetTimer() { clearInterval(this.timer); this.timeLeft = 120; }

  async loadCSV() {
    return new Promise((resolve, reject) => {
      this.vrLoadingText.setAttribute('troika-text', 'value', 'Loading location data...');
      Papa.parse('locations.csv', { download: true, header: true, skipEmptyLines: true,
        complete: (r) => {
          this.data = r.data.map((row, index) => ({...row, id: `loc-${index}`}));
          if (this.data.length === 0) return reject(new Error('No valid locations in CSV'));
          console.log("CSV data loaded.");
          resolve();
        }, error: (err) => reject(new Error(`CSV Error: ${err.message}`))
      });
    });
  }
  
  generateGamePlaylist() {
      const shuffledData = [...this.data].sort(() => 0.5 - Math.random());
      this.gamePlaylist = shuffledData.slice(0, this.totalRounds);
      console.log("Game playlist generated:", this.gamePlaylist.map(p => p.filename));
  }

  async loadRoundImage(location) {
    return new Promise((resolve, reject) => {
        console.log(`Loading image: ${location.filename}`);
        this.vrLoadingText.setAttribute('troika-text', 'value', 'Loading new location...');
        this.vrLoadingText.setAttribute('visible', 'true');

        // This is the core of the new method: just update the src.
        this.panoImage.onload = () => {
            console.log("Image loaded successfully.");
            this.vrLoadingText.setAttribute('visible', 'false');
            resolve(location);
        };
        this.panoImage.onerror = () => {
            console.error(`Failed to load image: ${location.filename}`);
            location.failedToLoad = true;
            this.vrLoadingText.setAttribute('visible', 'false');
            reject(new Error(`Failed to load image: ${location.filename}`));
        };

        this.panoImage.src = `Images/${location.filename.trim()}`;
    });
  }

  initMap() {
    if (this.map) this.map.remove();
    // *** ACTION REQUIRED: PASTE YOUR MAPTILER API KEY HERE ***
    const apiKey = '3AA53Tgefmb5xFuXQEZk'; // <--- PASTE KEY HERE

    this.map = new maplibregl.Map({
        container: this.mapContainer,
        style: `https://api.maptiler.com/maps/streets/style.json?key=${apiKey}`,
        center: [0, 0],
        zoom: 1,
        interactive: false,
        preserveDrawingBuffer: true // CRITICAL for canvas capture
    });

    this.map.on('render', () => this.updateMapTexture());
    console.log("MapLibre map initialized.");
  }

  updateMapTexture() {
    const canvas = this.map.getCanvas();
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    const mesh = this.mapPanel.getObject3D('mesh');
    if (mesh && mesh.material) {
        mesh.material.map = texture;
        mesh.material.needsUpdate = true;
    }
  }
  
  setUIState(state) {
      console.log(`Setting UI state to: ${state}`);
      const states = {
          LOADING: { guess: false, confirm: false, next: false, map: false, results: false },
          AWAITING_GUESS: { guess: true, confirm: false, next: false, map: false, results: false },
          PLACING_GUESS: { guess: false, confirm: true, next: false, map: true, results: false },
          SHOWING_RESULTS: { guess: false, confirm: false, next: this.round < this.totalRounds, map: true, results: true },
          GAME_OVER: { guess: false, confirm: false, next: false, map: true, results: true }
      };
      const currentState = states[state];
      if (!currentState) return;
      
      this.guessBtn.setAttribute('visible', currentState.guess);
      this.confirmBtn.setAttribute('visible', currentState.confirm);
      this.nextRoundBtn.setAttribute('visible', currentState.next);
      this.mapWrapper.setAttribute('visible', currentState.map);
      this.resultsPanel.setAttribute('visible', currentState.results);
  }

  async startNewRound() {
    console.log(`Starting round ${this.round + 1}`);
    this.cleanupPreviousRound();
    this.round++;
    if (this.round > this.totalRounds) {
        this.setUIState('GAME_OVER');
        this.resultsText.setAttribute('troika-text', 'value', `GAME OVER!\nFINAL SCORE: ${this.score}`);
        return;
    }

    this.acceptingInput = false; this.currentGuess = null;
    this.setUIState('LOADING');
    this.sky.setAttribute('material', 'color', '#333');
    this.sky.removeAttribute('src');

    try {
        const location = this.gamePlaylist[this.round - 1];
        await this.loadRoundImage(location);
        this.currentLocation = location;
        
        this.sky.setAttribute('src', '#pano-image');
        
        this.setUIState('AWAITING_GUESS');
        this.resetTimer(); this.startTimer();
        setTimeout(() => { this.acceptingInput = true; }, 500);
    } catch(err) {
        console.error(err);
        this.vrLoadingText.setAttribute('troika-text', 'value', `Error loading round. Skipping...`);
        setTimeout(() => this.startNewRound(), 2000);
    }
  }

  cleanupPreviousRound() {
    console.log("Cleaning up previous round.");
    if (this.guessMarker) { this.guessMarker.remove(); this.guessMarker = null; }
    if (this.map.getLayer('answer-line')) this.map.removeLayer('answer-line');
    if (this.map.getSource('answer-line')) this.map.removeSource('answer-line');
    if (this.map.getLayer('correct-pin')) this.map.removeLayer('correct-pin');
    if (this.map.getSource('correct-pin')) this.map.removeSource('correct-pin');
  }

  startGuessing() {
    console.log("Start guessing state.");
    this.setUIState('PLACING_GUESS');
    this.locationText.setAttribute('troika-text', 'value', 'Point on the map to place your guess');
    this.map.flyTo({ zoom: 2, center: [0, 0], speed: 1.5 });
  }
  
  handleControllerMapClick(uv) {
    const mapCanvas = this.map.getCanvas();
    const point = [uv.x * mapCanvas.width, uv.y * mapCanvas.height];
    const latlng = this.map.unproject(point);
    
    if (this.guessMarker) {
        this.guessMarker.setLngLat(latlng);
    } else {
        this.guessMarker = new maplibregl.Marker({color: "#007cff"}).setLngLat(latlng).addTo(this.map);
    }
    
    this.currentGuess = latlng;
    this.locationText.setAttribute('troika-text', 'value', 'Pin placed! Click CONFIRM GUESS');
    
    const mapDimensions = this.mapPanel.getAttribute('geometry');
    this.mapPin.setAttribute('position', `${(uv.x - 0.5) * mapDimensions.width} ${(uv.y - 0.5) * mapDimensions.height} 0`);
    this.mapPin.setAttribute('visible', 'true');
  }

  submitGuess() {
    if (!this.currentGuess) { this.locationText.setAttribute('troika-text', 'value', 'Please place a pin on the map first'); return; }
    this.endRound(true, this.currentGuess);
  }

  calculateScore(distance) {
    return Math.round(5000 * Math.exp(-0.000002 * distance));
  }

  endRound(guessed, guessLatLng) {
    console.log("Ending round.");
    this.acceptingInput = false; clearInterval(this.timer);
    this.mapPin.setAttribute('visible', 'false');

    const location = this.currentLocation;
    const actualLoc = [parseFloat(location.longitude), parseFloat(location.latitude)];
    let roundScore = 0, distance = 0;
    
    if (guessed) {
      distance = this.guessMarker.getLngLat().distanceTo(actualLoc);
      roundScore = this.calculateScore(distance);
      this.score += roundScore;
      this.scoreText.setAttribute('troika-text', 'value', `SCORE: ${this.score}`);
    }
    
    this.map.addSource('correct-pin', { type: 'geojson', data: { type: 'FeatureCollection', features: [{ type: 'Feature', geometry: { type: 'Point', coordinates: actualLoc } }] } });
    this.map.addLayer({ id: 'correct-pin', type: 'symbol', source: 'correct-pin', layout: { 'icon-image': 'marker', 'icon-size': 1.5, 'icon-allow-overlap': true }, paint: {'icon-color': '#ff0000'} });

    if (guessed) {
        const lineData = { type: 'Feature', geometry: { type: 'LineString', coordinates: [this.guessMarker.getLngLat().toArray(), actualLoc] }};
        this.map.addSource('answer-line', { type: 'geojson', data: lineData });
        this.map.addLayer({ id: 'answer-line', type: 'line', source: 'answer-line', paint: { 'line-color': '#007cff', 'line-width': 4 } });
        const bounds = new maplibregl.LngLatBounds(this.guessMarker.getLngLat(), actualLoc);
        this.map.fitBounds(bounds, { padding: 80 });
    } else {
        this.map.flyTo({ center: actualLoc, zoom: 5 });
    }
    
    const resultsValue = `ROUND ${this.round}/${this.totalRounds}\n` + (guessed ? `DISTANCE: ${(distance/1000).toFixed(1)} km\nPOINTS: ${roundScore}` : 'TIME EXPIRED!') + `\n\nTOTAL SCORE: ${this.score}`;
    this.resultsText.setAttribute('troika-text', 'value', resultsValue);
    
    this.setUIState('SHOWING_RESULTS');
    setTimeout(() => { this.acceptingInput = true; }, 500);
  }
}

document.addEventListener('DOMContentLoaded', () => { new VRGeoGuessr(); });
</script>
</body>
</html>
