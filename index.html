<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>VR GeoGuessr - Final Polished Version</title>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-troika-text/dist/aframe-troika-text.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap" rel="stylesheet">
<style>
  body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
  .splash-background { background: url('splash.png') no-repeat center center fixed; background-size: cover; }
  #startButton { font-family: 'Orbitron', sans-serif; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; font-size: 30px; background: #e0202d; color: #fff; border: none; border-radius: 5px; cursor: pointer; z-index: 999; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
  #mapContainer { position: fixed; top: -10000px; left: -10000px; width: 1024px; height: 640px; background: white; }
</style>
</head>
<body class="splash-background">

<button id="startButton">Click me with your Controller to Start Game!</button>
<div id="mapContainer"></div>

<!-- *** FIX: Wrap the scene in a div to prevent html2canvas from traversing it *** -->
<div id="aframe-wrapper">
    <a-scene id="scene" 
             webxr="referenceSpaceType: local-floor"
             vr-mode-ui="enabled: true"
             renderer="antialias: true; logarithmicDepthBuffer: true"
             visible="false">
             
      <a-assets id="assets-container">
        <img id="fallback" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z/C/HgAGgwJ/lK3Q6wAAAABJRU5ErkJggg==" crossorigin="anonymous">
        <img id="pano-image" crossorigin="anonymous">
      </a-assets>
      
      <a-sky id="sky" material="shader: flat; color: #333"></a-sky>
      
      <a-entity id="cameraRig" position="0 1.6 0">
        <a-camera id="camera" wasd-controls-enabled="false">
          <a-entity id="vrLoadingText" visible="false" position="0 0 -1.5">
              <a-entity troika-text="value: Loading...; align: center; color: white; fontSize: 0.1;"></a-entity>
          </a-entity>
        </a-camera>
        <a-entity id="rightController" oculus-touch-controls="hand: right" laser-controls="hand: right" raycaster="objects: .clickable; far: 20;"></a-entity>
      </a-entity>
      
      <a-entity id="uiWrapper" visible="false">
          <a-entity id="gameUI" position="0 1.2 -2.5">
            <a-plane id="guessBtn" class="clickable" position="0 0 0" width="1.2" height="0.4" color="#9C27B0" visible="false">
                <a-entity troika-text="value: MAKE GUESS; align: center; color: white; fontSize: 0.1; font: Orbitron.ttf;" position="0 0 0.01"></a-entity>
            </a-plane>
            <a-plane id="confirmBtn" class="clickable" position="0 0 0" width="1.2" height="0.4" color="#FF9800" visible="false">
                <a-entity troika-text="value: CONFIRM GUESS; align: center; color: white; fontSize: 0.1; font: Orbitron.ttf;" position="0 0 0.01"></a-entity>
            </a-plane>
            <a-plane id="nextRoundBtn" class="clickable" position="0 0 0" width="1.2" height="0.4" color="#4CAF50" visible="false">
                <a-entity troika-text="value: NEXT ROUND; align: center; color: white; fontSize: 0.1; font: Orbitron.ttf;" position="0 0 0.01"></a-entity>
            </a-plane>
          </a-entity>
          
          <a-entity id="mapWrapper" position="-2.5 1.5 -2.5" rotation="0 35 0" visible="false">
            <a-plane id="mapPanel" class="clickable" width="2" height="1.25" material="shader: flat; side: double; transparent: true;">
              <a-entity id="locationText" position="0 -0.75 0.01" troika-text="value:; align: center; color: black; fontSize: 0.06; outlineWidth: 0.005; outlineColor: #FFF; font: Orbitron.ttf;" ></a-entity>
            </a-plane>
            <a-entity id="mapPin" visible="false">
                <a-cone color="red" radius-bottom="0.03" radius-top="0" height="0.1" position="0 0.05 0.01" rotation="-90 0 0"></a-cone>
            </a-entity>
          </a-entity>
          
          <a-entity id="scoreAndTimer" position="0 2.8 -2.5">
            <a-entity id="scoreText" position="0 0 0" troika-text="value: SCORE: 0; align: center; color: white; fontSize: 0.1; font: Orbitron.ttf;"></a-entity>
            <a-entity id="timerText" position="0.9 0 0" troika-text="value: 02:00; align: right; color: white; fontSize: 0.1; font: Orbitron.ttf;"></a-entity>
          </a-entity>
          
          <a-entity id="resultsPanel" position="0 1.9 -2.5" visible="false">
            <a-plane width="2.2" height="1.2" color="#333333" opacity="0.9">
              <a-entity id="resultsText" position="0 0 0.01" troika-text="value:; align: center; color: white; fontSize: 0.07; whiteSpace: normal; maxWidth: 2; font: Orbitron.ttf;"></a-entity>
            </a-plane>
          </a-entity>
      </a-entity>
    </a-scene>
</div>

<script>
class VRGeoGuessr {
  constructor() {
    this.mapContainer = document.getElementById('mapContainer');
    this.startButton = document.getElementById('startButton');
    this.scene = document.getElementById('scene');
    this.sky = document.getElementById('sky');
    this.panoImage = document.getElementById('pano-image');
    this.uiWrapper = document.getElementById('uiWrapper');
    this.vrLoadingText = document.getElementById('vrLoadingText');
    this.guessBtn = document.getElementById('guessBtn');
    this.confirmBtn = document.getElementById('confirmBtn');
    this.nextRoundBtn = document.getElementById('nextRoundBtn');
    this.mapWrapper = document.getElementById('mapWrapper');
    this.mapPanel = document.getElementById('mapPanel');
    this.mapPin = document.getElementById('mapPin');
    this.locationText = document.getElementById('locationText');
    this.scoreText = document.getElementById('scoreText');
    this.timerText = document.getElementById('timerText');
    this.resultsPanel = document.getElementById('resultsPanel');
    this.resultsText = document.getElementById('resultsText');

    this.data = [];
    this.gamePlaylist = [];
    this.leafletMap = null;
    this.roundElements = [];
    this.score = 0;
    this.round = 0;
    this.totalRounds = 5;
    this.timer = null;
    this.timeLeft = 120;
    this.currentGuess = null;
    this.acceptingInput = false;

    this.bindEvents();
  }

  bindEvents() {
    this.startButton.addEventListener('click', () => this.initExperience());
    this.guessBtn.addEventListener('click', () => { if (this.acceptingInput) this.startGuessing(); });
    this.confirmBtn.addEventListener('click', () => { if (this.acceptingInput) this.submitGuess(); });
    this.nextRoundBtn.addEventListener('click', () => { if (this.acceptingInput) this.startNewRound(); });
    this.mapPanel.addEventListener('click', (event) => {
        if (this.acceptingInput && this.mapWrapper.getAttribute('visible') && event.detail.intersection) {
            this.handleControllerMapClick(event.detail.intersection.uv);
        }
    });
  }

  initExperience() {
    console.log("Initializing VR Experience...");
    this.startButton.style.display = 'none';
    document.body.classList.remove('splash-background');
    
    this.scene.setAttribute('visible', 'true');
    this.vrLoadingText.setAttribute('visible', 'true');
    this.scene.enterVR().then(() => this.loadAndStartGame())
      .catch(err => { console.error("Could not enter VR mode:", err); this.loadAndStartGame(); });
  }
  
  async loadAndStartGame() {
    console.log("VR Session started. Loading assets...");
    try {
        const controllerPromise = new Promise(resolve => this.scene.addEventListener('controllerconnected', resolve, { once: true }));
        this.initMap();
        await this.loadCSV();
        this.generateGamePlaylist();
        
        console.log("Waiting for controllers to connect...");
        await controllerPromise;
        console.log("Controllers connected.");
        
        this.uiWrapper.setAttribute('visible', 'true');
        this.startNewRound();
    } catch(error) {
        this.vrLoadingText.setAttribute('troika-text', 'value', `Error: ${error.message}`);
    }
  }

  updateTimer() {
    const minutes = Math.floor(this.timeLeft / 60);
    const seconds = this.timeLeft % 60;
    this.timerText.setAttribute('troika-text', 'value', `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);
  }

  startTimer() {
    this.updateTimer();
    this.timer = setInterval(() => {
      this.timeLeft--; this.updateTimer();
      if (this.timeLeft <= 0) { clearInterval(this.timer); this.endRound(false); }
    }, 1000);
  }

  resetTimer() { clearInterval(this.timer); this.timeLeft = 120; }

  async loadCSV() {
    return new Promise((resolve, reject) => {
      this.vrLoadingText.setAttribute('troika-text', 'value', 'Loading location data...');
      Papa.parse('locations.csv', { download: true, header: true, skipEmptyLines: true,
        complete: (r) => {
          this.data = r.data.map((row, index) => ({...row, id: `loc-${index}`}));
          if (this.data.length === 0) return reject(new Error('No valid locations in CSV'));
          console.log("CSV data loaded.");
          resolve();
        }, error: (err) => reject(new Error(`CSV Error: ${err.message}`))
      });
    });
  }
  
  generateGamePlaylist() {
      const shuffledData = [...this.data].sort(() => 0.5 - Math.random());
      this.gamePlaylist = shuffledData.slice(0, this.totalRounds);
      console.log("Game playlist generated:", this.gamePlaylist.map(p => p.filename));
  }

  async loadRoundImage(location) {
    return new Promise((resolve, reject) => {
        console.log(`Loading image: ${location.filename}`);
        this.vrLoadingText.setAttribute('troika-text', 'value', 'Loading new location...');
        this.vrLoadingText.setAttribute('visible', 'true');
        this.panoImage.onload = () => {
            console.log("Image loaded successfully.");
            this.vrLoadingText.setAttribute('visible', 'false');
            resolve(location);
        };
        this.panoImage.onerror = () => {
            console.error(`Failed to load image: ${location.filename}`);
            location.failedToLoad = true;
            this.vrLoadingText.setAttribute('visible', 'false');
            reject(new Error(`Failed to load image: ${location.filename}`));
        };
        this.panoImage.src = `Images/${location.filename.trim()}`;
    });
  }

  initMap() {
    console.log("Initializing Leaflet map...");
    if (this.leafletMap) this.leafletMap.remove();
    this.leafletMap = L.map(this.mapContainer, { center: [0, 0], zoom: 1, zoomControl: false, attributionControl: false, preferCanvas: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18, crossOrigin: true }).addTo(this.leafletMap);
  }

  updateMapTexture() {
    console.log("Requesting map texture update...");
    setTimeout(() => {
        html2canvas(this.mapContainer, { useCORS: true, logging: false, scale: 0.75 }).then(canvas => {
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            const mesh = this.mapPanel.getObject3D('mesh');
            if (mesh && mesh.material) {
                mesh.material.map = texture;
                mesh.material.needsUpdate = true;
                console.log("Map texture successfully applied.");
            }
        }).catch(err => { console.error("html2canvas error:", err); });
    }, 200); 
  }
  
  setUIState(state) {
      console.log(`Setting UI state to: ${state}`);
      this.guessBtn.setAttribute('visible', false);
      this.confirmBtn.setAttribute('visible', false);
      this.nextRoundBtn.setAttribute('visible', false);
      this.mapWrapper.setAttribute('visible', false);
      this.resultsPanel.setAttribute('visible', false);
      
      switch(state) {
          case 'LOADING':
              break;
          case 'AWAITING_GUESS':
              this.guessBtn.setAttribute('visible', true);
              break;
          case 'PLACING_GUESS':
              this.confirmBtn.setAttribute('visible', true);
              this.mapWrapper.setAttribute('visible', true);
              break;
          case 'SHOWING_RESULTS':
              this.mapWrapper.setAttribute('visible', true);
              this.resultsPanel.setAttribute('visible', true);
              if (this.round < this.totalRounds) {
                  this.nextRoundBtn.setAttribute('visible', true);
              }
              break;
          case 'GAME_OVER':
              this.mapWrapper.setAttribute('visible', true);
              this.resultsPanel.setAttribute('visible', true);
              break;
      }
  }

  async startNewRound() {
    console.log(`Starting round ${this.round + 1}`);
    this.cleanupPreviousRound();
    this.round++;
    if (this.round > this.totalRounds) {
        this.setUIState('GAME_OVER');
        this.resultsText.setAttribute('troika-text', 'value', `GAME OVER!\nFINAL SCORE: ${this.score}`);
        return;
    }

    this.acceptingInput = false; this.currentGuess = null;
    this.setUIState('LOADING');
    this.sky.setAttribute('material', 'color', '#333');
    this.sky.removeAttribute('src');

    try {
        const location = this.gamePlaylist[this.round - 1];
        await this.loadRoundImage(location);
        this.currentLocation = location;
        
        this.sky.setAttribute('src', '#pano-image');
        
        this.setUIState('AWAITING_GUESS');
        this.resetTimer(); this.startTimer();
        setTimeout(() => { this.acceptingInput = true; }, 500);
    } catch(err) {
        console.error(err);
        this.vrLoadingText.setAttribute('troika-text', 'value', `Error loading round. Skipping...`);
        setTimeout(() => this.startNewRound(), 2000);
    }
  }

  cleanupPreviousRound() {
    console.log("Cleaning up previous round.");
    this.roundElements.forEach(el => this.leafletMap.removeLayer(el));
    this.roundElements = [];
  }

  startGuessing() {
    console.log("UI State: PLACING_GUESS");
    this.setUIState('PLACING_GUESS');
    this.locationText.setAttribute('troika-text', 'value', 'Point on the map to place your guess');
    this.leafletMap.setView([20, 0], 2);
    this.updateMapTexture();
  }
  
  handleControllerMapClick(uv) {
    const mapSize = this.leafletMap.getSize();
    const point = L.point(uv.x * mapSize.x, (1 - uv.y) * mapSize.y);
    const latlng = this.leafletMap.containerPointToLatLng(point);

    if (this.roundElements.length > 0) {
        this.roundElements[0].setLatLng(latlng);
    } else {
        const guessMarker = L.marker(latlng).addTo(this.leafletMap);
        this.roundElements.push(guessMarker);
    }
    
    this.currentGuess = latlng;
    this.locationText.setAttribute('troika-text', 'value', 'Pin placed! Click CONFIRM GUESS');
    this.mapPin.setAttribute('position', `${(uv.x - 0.5) * 2} ${(uv.y - 0.5) * 1.25} 0`);
    this.mapPin.setAttribute('visible', 'true');
    this.updateMapTexture();
  }

  submitGuess() {
    if (!this.currentGuess) { this.locationText.setAttribute('troika-text', 'value', 'Please place a pin on the map first'); return; }
    console.log("Guess submitted.");
    this.endRound(true, this.currentGuess);
  }

  calculateScore(distance) {
    return Math.round(5000 * Math.exp(-0.000002 * distance));
  }

  endRound(guessed, guessLatLng) {
    console.log("Ending round.");
    this.acceptingInput = false; clearInterval(this.timer);
    this.mapPin.setAttribute('visible', 'false');

    const location = this.currentLocation;
    const actualLoc = L.latLng(parseFloat(location.latitude), parseFloat(location.longitude));
    let roundScore = 0, distance = 0;
    
    if (guessed) {
      distance = this.leafletMap.distance(guessLatLng, actualLoc);
      roundScore = this.calculateScore(distance);
      this.score += roundScore;
      this.scoreText.setAttribute('troika-text', 'value', `SCORE: ${this.score}`);
    }
    
    const correctPin = L.marker(actualLoc, { icon: L.divIcon({className: 'correct-pin', html: 'üìç', iconSize:[24,24], iconAnchor:[12,24]}) }).addTo(this.leafletMap);
    this.roundElements.push(correctPin);

    if (guessed) {
        const line = L.polyline([guessLatLng, actualLoc], {color: 'blue'}).addTo(this.leafletMap);
        this.roundElements.push(line);
        this.leafletMap.fitBounds(line.getBounds().pad(0.2));
    } else {
        this.leafletMap.setView(actualLoc, 5);
    }
    
    const resultsValue = `ROUND ${this.round}/${this.totalRounds}\n` + (guessed ? `DISTANCE: ${(distance/1000).toFixed(1)} km\nPOINTS: ${roundScore}` : 'TIME EXPIRED!') + `\n\nTOTAL SCORE: ${this.score}`;
    this.resultsText.setAttribute('troika-text', 'value', resultsValue);
    
    this.setUIState(this.round < this.totalRounds ? 'SHOWING_RESULTS' : 'GAME_OVER');
    this.updateMapTexture(); 
    
    if (this.round < this.totalRounds) {
        setTimeout(() => { this.acceptingInput = true; }, 500);
    }
  }
}

document.addEventListener('DOMContentLoaded', () => { new VRGeoGuessr(); });
</script>
</body>
</html>
